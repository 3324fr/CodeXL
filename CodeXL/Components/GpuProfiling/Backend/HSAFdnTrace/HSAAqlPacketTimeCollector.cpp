//==============================================================================
// Copyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved.
/// \author AMD Developer Tools Team
/// \file
/// \brief  This file contains code to collect timestamps from AQL packets
//==============================================================================

#include <AMDTOSWrappers/Include/osCondition.h>
#include "../Common/Defs.h"
#include "AutoGenerated/HSATraceInterception.h"
#include "HSAAqlPacketTimeCollector.h"

HSATimeCollectorGlobals::HSATimeCollectorGlobals() :
    m_doQuit(false)
{
    if (!m_dispatchesInFlight.lockCondition())
    {
        Log(logERROR, "unable to lock condition\n");
    }
}

HSASignalPool::HSASignalPool()
{
}

HSASignalPool::~HSASignalPool()
{
    Clear();
}

void HSASignalPool::Clear()
{
    size_t poolSize = m_signalPool.size();

    for (size_t i = 0; i < poolSize; i++)
    {
        g_pRealCoreFunctions->hsa_signal_destroy_fn(m_signalPool.top());
        m_signalPool.pop();
    }

    SpAssert(m_signalPool.empty())
}

bool HSASignalPool::AcquireSignal(hsa_signal_value_t initialValue, hsa_signal_t& signal)
{
    if (0 == m_signalPool.size())
    {
        hsa_status_t status = g_pRealCoreFunctions->hsa_signal_create_fn(initialValue, 0, nullptr, &signal);
        SpAssert(HSA_STATUS_SUCCESS == status);

        return HSA_STATUS_SUCCESS == status;
    }

    {
        AMDTScopeLock lock(m_signalPoolMtx);

        if (0 == m_signalPool.size())
        {
            hsa_status_t status = g_pRealCoreFunctions->hsa_signal_create_fn(initialValue, 0, nullptr, &signal);
            SpAssert(HSA_STATUS_SUCCESS == status);

            return HSA_STATUS_SUCCESS == status;
        }

        signal = m_signalPool.top();
        m_signalPool.pop();
        g_pRealCoreFunctions->hsa_signal_store_relaxed_fn(signal, initialValue);

        return true;
    }
}

bool HSASignalPool::ReleaseSignal(hsa_signal_t signal)
{
    if (s_MAX_POOL_SIZE < m_signalPool.size())
    {
        g_pRealCoreFunctions->hsa_signal_destroy_fn(signal);
    }
    else
    {
        AMDTScopeLock lock(m_signalPoolMtx);
        m_signalPool.push(signal);
    }

    return true;
}

void HSASignalQueue::AddSignalToBack(const HSAPacketSignalReplacer& signal)
{
    AMDTScopeLock lock(m_signalQueueMtx);
    m_signalQueue.push(signal);
}

void HSASignalQueue::GetSignalFromFront(HSAPacketSignalReplacer& outSignal)
{
    AMDTScopeLock lock(m_signalQueueMtx);
    outSignal = m_signalQueue.front();
    m_signalQueue.pop();
}

size_t HSASignalQueue::GetSize() const
{
    return m_signalQueue.size();
}

void HSASignalQueue::Clear()
{
    while (!m_signalQueue.empty())
    {
        m_signalQueue.pop();
    }
}

const unsigned int HSASignalCollectorThread::m_deferLen;

HSASignalCollectorThread::HSASignalCollectorThread() : osThread(gtString(L"HSASignalCollectorThread"), false, false /*true*/),
    m_index(0)
{
    hsa_signal_t& forceSignalCollection = HSATimeCollectorGlobals::Instance()->m_forceSignalCollection;
    hsa_status_t status = g_pRealCoreFunctions->hsa_signal_create_fn(0, 0, nullptr, &forceSignalCollection);

    if (HSA_STATUS_SUCCESS != status)
    {
        Log(logERROR, "Unable to create signal\n");
    }
}

int HSASignalCollectorThread::entryPoint()
{
    int retVal = 0;

    hsa_signal_t signalList[2];
    hsa_signal_value_t signalValueList[2];
    hsa_signal_condition_t signalConditionList[2];

    signalList[0] = HSATimeCollectorGlobals::Instance()->m_forceSignalCollection;
    signalValueList[0] = 1;
    signalConditionList[0] = HSA_SIGNAL_CONDITION_EQ;

    signalValueList[1] = 1;
    signalConditionList[1] = HSA_SIGNAL_CONDITION_LT;

    bool doFlush = false;
    bool doIdleFlush = false;

    // provide local aliases to some of the globals
    bool& doQuit = HSATimeCollectorGlobals::Instance()->m_doQuit;
    static unsigned int numDispatches = 0;

    while (true)
    {
        while (0 != HSASignalQueue::Instance()->GetSize() || doFlush)
        {
            if (!doFlush)
            {
                HSASignalQueue::Instance()->GetSignalFromFront(m_deferList[m_index]);
                signalList[1] = m_deferList[m_index].m_profilerSignal;
            }

            doFlush = false;

            if (1 == g_pRealAmdExtFunctions->hsa_amd_signal_wait_any_fn(2, signalList, signalConditionList, signalValueList, static_cast<uint64_t>(-1), HSA_WAIT_STATE_BLOCKED, nullptr))
            {
                if (0 != m_deferList[m_index].m_originalSignal.handle)
                {
                    // update the original signal so the app will know that it is complete
                    g_pRealCoreFunctions->hsa_signal_add_relaxed_fn(m_deferList[m_index].m_originalSignal, -1);
                }

                m_index++;
            }
            else
            {
                doFlush = true;
            }

            if (doQuit)
            {
                doFlush = true;
            }

            if (m_index == m_deferLen || doFlush)
            {
                for (unsigned int i = 0; i < m_index; i++)
                {
                    HSAPacketSignalReplacer& replacer = m_deferList[i];

                    hsa_amd_profiling_dispatch_time_t time;
                    g_pRealAmdExtFunctions->hsa_amd_profiling_get_dispatch_time_fn(replacer.m_agent, replacer.m_profilerSignal, &time);
                    numDispatches++;
                    replacer.m_pAqlPacket->SetTimestamps(time.start, time.end);

                    HSASignalPool::Instance()->ReleaseSignal(replacer.m_profilerSignal);
                }

                if (doFlush)
                {
                    g_pRealCoreFunctions->hsa_signal_store_screlease_fn(signalList[0], 0); // this is HSATimeCollectorGlobals::Instance()->m_forceSignalCollection
                    m_deferList[0] = m_deferList[m_index];
                }

                m_index = 0;
            }

            if (doQuit)
            {
                return retVal;
            }

            if (doIdleFlush)
            {
                doFlush = false;
                doIdleFlush = false;
            }
        }

        HSATimeCollectorGlobals::Instance()->m_dispatchesInFlight.waitForCondition();

        if (1 == g_pRealCoreFunctions->hsa_signal_load_relaxed_fn(signalList[0]))
        {
            doFlush = true;
            doIdleFlush = true;
            signalList[1] = signalList[0];
        }
    }

    return retVal;
}
