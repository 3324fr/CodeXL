//==============================================================================
// Copyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved.
/// \author AMD Developer Tools Team
/// \file
/// \brief  This file contains classes for tracing HSA AQL Packets
//==============================================================================

#include <algorithm>
#include <iomanip>

#include "DeviceInfoUtils.h"
#include "../Common/StringUtils.h"
#include "HSAFdnAPIInfoManager.h"
#include "HSAAqlPacketInfo.h"
#include "FinalizerInfoManager.h"
#include "AutoGenerated/HSATraceInterception.h"
#include "AutoGenerated/HSATraceStringOutput.h"

static const uint64_t s_invalidPacketId = static_cast<uint64_t>(-1);

HSAAqlPacketBase::HSAAqlPacketBase(hsa_packet_type_t type) :
   m_type(type),
   m_packetId(s_invalidPacketId),
   m_agent({0}),
   m_pQueue(nullptr),
   m_isReady(false)
{
}

HSAAqlPacketBase:: ~HSAAqlPacketBase()
{
}

bool HSAAqlPacketBase::WritePacketEntry(std::ostream& sout, bool bTimeout)
{
    uint32_t deviceId;
    hsa_status_t status = g_pRealCoreFunctions->hsa_agent_get_info_fn(m_agent, static_cast<hsa_agent_info_t>(HSA_AMD_AGENT_INFO_CHIP_ID), &deviceId);

    std::string strDeviceName = "<UnknownDeviceName>";

    if (HSA_STATUS_SUCCESS == status)
    {
        GDT_GfxCardInfo cardInfo;

        // TODO: need to get revision id from HSA runtime (SWDEV-79571)
        if (AMDTDeviceInfoUtils::Instance()->GetDeviceInfo(deviceId, REVISION_ID_ANY, cardInfo))
        {
            strDeviceName = std::string(cardInfo.m_szCALName);
        }
    }

    // agent (device) name
    sout << std::left << std::setw(64) << strDeviceName;

    // agent (device) handle
    sout << std::left << std::setw(21) << HSATraceStringUtils::Get_hsa_agent_t_String(m_agent);

    // queue index
    size_t queueIndex = 0;
    HSAAPIInfoManager::Instance()->GetQueueIndex(m_pQueue, queueIndex);
    sout << std::left << std::setw(6) << StringUtils::ToString(queueIndex);

    // queue handle
    sout << std::left << std::setw(21) << StringUtils::ToHexString(m_pQueue);

    // packet type
    sout << std::left << std::setw(35) << HSATraceStringUtils::Get_hsa_packet_type_t_String(m_type);

    // packet id
    sout << std::left << std::setw(10) << m_packetId;

    return true;
}

HSAAqlKernelDispatchPacket::HSAAqlKernelDispatchPacket(hsa_kernel_dispatch_packet_t kernelDispatchPacket) :
    HSAAqlPacketBase(HSA_PACKET_TYPE_KERNEL_DISPATCH),
    m_start(0),
    m_end(0),
    m_packet(kernelDispatchPacket)
{
}

bool HSAAqlKernelDispatchPacket::WritePacketEntry(std::ostream& sout, bool bTimeout)
{
    // NOTE: the reason for the odd ordering of items below (for instance, the location of the
    // call to base class) is to match the order of items when not using aql-packet-tracing.
    // this means the HSA ATP file parser does not need to be updated and CodeXL will be able
    // to load the .atp file.
    FinalizerInfoManager* pFinalizerInfoMan = FinalizerInfoManager::Instance();

    std::string symName;

    if (pFinalizerInfoMan->m_codeHandleToSymbolHandleMap.count(m_packet.kernel_object) > 0)
    {
        uint64_t symHandle = pFinalizerInfoMan->m_codeHandleToSymbolHandleMap[m_packet.kernel_object];

        if (pFinalizerInfoMan->m_symbolHandleToNameMap.count(symHandle) > 0)
        {
            symName = pFinalizerInfoMan->m_symbolHandleToNameMap[symHandle];
            Log(logMESSAGE, "Lookup: CodeHandle: %llu, SymHandle: %llu, symName: %s\n", m_packet.kernel_object, symHandle, symName.c_str());
        }
    }

    if (symName.empty())
    {
        symName = "<UnknownKernelName>";
    }

    // kernel name
    sout << std::left << std::setw(std::max((size_t)50, symName.length() + 1)) << symName;

    // kernel pointer
    sout << std::left << std::setw(21) << StringUtils::ToHexString(m_packet.kernel_object);

    // start timestamp
    sout << std::left << std::setw(21) << m_start;

    // end timestamp
    sout << std::left << std::setw(21) << m_end;

    // call base class
    bool retVal = HSAAqlPacketBase::WritePacketEntry(sout, bTimeout);

    // kernel dispatch packet
    sout << HSATraceStringUtils::Get_hsa_kernel_dispatch_packet_t_String(m_packet);

    return retVal;
}

void HSAAqlKernelDispatchPacket::SetTimestamps(uint64_t start, uint64_t end)
{
    m_start = start;
    m_end = end;
    m_isReady = true;
}

HSAAqlAgentDispatchPacket::HSAAqlAgentDispatchPacket(hsa_agent_dispatch_packet_t agentDispatchPacket) :
    HSAAqlPacketBase(HSA_PACKET_TYPE_AGENT_DISPATCH),
    m_packet(agentDispatchPacket)
{
    m_isReady = true; // this packet type is always ready
}

bool HSAAqlAgentDispatchPacket::WritePacketEntry(std::ostream& sout, bool bTimeout)
{
    bool retVal = HSAAqlPacketBase::WritePacketEntry(sout, bTimeout);
    sout << HSATraceStringUtils::Get_hsa_agent_dispatch_packet_t_String(m_packet);

    return retVal;
}

HSAAqlBarrierAndPacket::HSAAqlBarrierAndPacket(hsa_barrier_and_packet_t barrierAndPacket) :
    HSAAqlPacketBase(HSA_PACKET_TYPE_BARRIER_AND),
    m_packet(barrierAndPacket)
{
    m_isReady = true; // this packet type is always ready
}

bool HSAAqlBarrierAndPacket::WritePacketEntry(std::ostream& sout, bool bTimeout)
{
    bool retVal = HSAAqlPacketBase::WritePacketEntry(sout, bTimeout);
    sout << HSATraceStringUtils::Get_hsa_barrier_and_packet_t_String(m_packet);

    return retVal;
}

HSAAqlBarrierOrPacket::HSAAqlBarrierOrPacket(hsa_barrier_or_packet_t barrierOrPacket) :
    HSAAqlPacketBase(HSA_PACKET_TYPE_BARRIER_OR),
    m_packet(barrierOrPacket)
{
    m_isReady = true; // this packet type is always ready
}

bool HSAAqlBarrierOrPacket::WritePacketEntry(std::ostream& sout, bool bTimeout)
{
    bool retVal = HSAAqlPacketBase::WritePacketEntry(sout, bTimeout);
    sout << HSATraceStringUtils::Get_hsa_barrier_or_packet_t_String(m_packet);

    return retVal;
}

